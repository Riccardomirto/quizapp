<!DOCTYPE html>
<html lang="it" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Note Recorder MP3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .disabled-button {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="h-full bg-gray-900 text-white flex items-center justify-center p-4">
    <div class="w-full max-w-md mx-auto bg-gray-800 rounded-2xl shadow-lg p-6 space-y-6">
        <header class="text-center">
            <h1 class="text-2xl font-bold text-white">Registratore Note Audio</h1>
            <p class="text-gray-400">Registra, ascolta e scarica le tue note in MP3.</p>
        </header>

        <main id="app-container" class="space-y-6">
            <!-- Stato Iniziale e Registrazione -->
            <div id="recorder-view" class="text-center space-y-4">
                <button id="recordButton" class="w-24 h-24 bg-red-600 hover:bg-red-700 rounded-full flex items-center justify-center mx-auto transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 focus:ring-offset-gray-800">
                    <div id="mic-icon">
                        <svg class="w-10 h-10 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 006-6v-1.5a6 6 0 00-12 0v1.5a6 6 0 006 6z" />
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5" />
                        </svg>
                    </div>
                    <div id="stop-icon" class="hidden">
                         <svg class="w-10 h-10 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.5 7.5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-9a3 3 0 01-3-3v-9z" clip-rule="evenodd" />
                        </svg>
                    </div>
                </button>
                <div id="timer" class="text-2xl font-mono text-gray-300">00:00</div>
                <div id="status-text" class="text-gray-400 h-5">Clicca per registrare</div>
            </div>
            
            <!-- Stato Finale: Player e Download -->
            <div id="player-view" class="hidden space-y-4">
                 <div class="bg-gray-700 p-4 rounded-lg space-y-3">
                     <div class="flex items-center gap-4">
                        <button id="playPauseButton" class="w-12 h-12 bg-blue-600 hover:bg-blue-700 rounded-full flex items-center justify-center transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 focus:ring-offset-gray-800">
                            <div id="play-icon">
                                <svg class="w-6 h-6 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.529-2.33 2.779-1.643l11.54 6.647c1.295.742 1.295 2.545 0 3.286L7.279 20.99c-1.25.717-2.779-.217-2.779-1.643V5.653z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div id="pause-icon" class="hidden">
                                <svg class="w-6 h-6 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 01.75-.75H9a.75.75 0 01.75.75v13.5a.75.75 0 01-.75.75H7.5a.75.75 0 01-.75-.75V5.25zm7.5 0a.75.75 0 01.75-.75h1.5a.75.75 0 01.75.75v13.5a.75.75 0 01-.75.75h-1.5a.75.75 0 01-.75-.75V5.25z" clip-rule="evenodd" />
                                </svg>
                            </div>
                        </button>
                        <div class="flex-grow">
                             <input type="range" id="progressBar" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer" value="0" min="0" max="100">
                        </div>
                        <div id="duration" class="text-sm font-mono text-gray-300">00:00</div>
                    </div>
                </div>
                <div class="flex items-center justify-center gap-4">
                    <a id="downloadButton" href="#" class="flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 focus:ring-offset-gray-800">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 1.5a.75.75 0 01.75.75V11.25l1.22-1.22a.75.75 0 011.06 1.06l-2.5 2.5a.75.75 0 01-1.06 0l-2.5-2.5a.75.75 0 111.06-1.06l1.22 1.22V2.25A.75.75 0 0112 1.5zM2.25 12a.75.75 0 01.75.75v6c0 .414.336.75.75.75h15a.75.75 0 00.75-.75v-6a.75.75 0 011.5 0v6A2.25 2.25 0 0119.5 21H4.5A2.25 2.25 0 012.25 18.75v-6a.75.75 0 01.75-.75z" />
                        </svg>
                        Scarica Registrazione
                    </a>
                    <button id="newRecordingButton" class="flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium text-white bg-gray-600 rounded-lg hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 focus:ring-offset-gray-800">
                         <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                           <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-4.991-2.695v-2.257a2.25 2.25 0 00-2.25-2.25H10.5a2.25 2.25 0 00-2.25 2.25v2.257m1.5-10.23l-3.182 3.182a8.25 8.25 0 000 11.667l3.182 3.182" />
                         </svg>
                         Nuova Registrazione
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const STATES = {
            IDLE: 'IDLE',
            RECORDING: 'RECORDING',
            PROCESSING: 'PROCESSING',
            FINISHED: 'FINISHED',
        };

        let currentState = STATES.IDLE;
        let mediaRecorder;
        let audioChunks = [];
        let timerInterval;
        let mp3Url = null;

        // Elementi UI
        const recordButton = document.getElementById('recordButton');
        const timerEl = document.getElementById('timer');
        const statusTextEl = document.getElementById('status-text');
        const recorderView = document.getElementById('recorder-view');
        const playerView = document.getElementById('player-view');
        const audioPlayer = new Audio();
        const playPauseButton = document.getElementById('playPauseButton');
        const progressBar = document.getElementById('progressBar');
        const durationEl = document.getElementById('duration');
        const downloadButton = document.getElementById('downloadButton');
        const newRecordingButton = document.getElementById('newRecordingButton');
        
        const micIcon = document.getElementById('mic-icon');
        const stopIcon = document.getElementById('stop-icon');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');


        // Funzione per aggiornare l'UI in base allo stato
        const updateUI = (state) => {
            currentState = state;
            
            // Reset
            recorderView.classList.add('hidden');
            playerView.classList.add('hidden');
            recordButton.classList.remove('disabled-button');
            statusTextEl.textContent = '';
            micIcon.classList.remove('hidden');
            stopIcon.classList.add('hidden');


            if (state === STATES.IDLE) {
                recorderView.classList.remove('hidden');
                timerEl.textContent = '00:00';
                statusTextEl.textContent = 'Clicca per registrare';
            } else if (state === STATES.RECORDING) {
                recorderView.classList.remove('hidden');
                micIcon.classList.add('hidden');
                stopIcon.classList.remove('hidden');
                statusTextEl.textContent = 'Registrazione in corso...';
            } else if (state === STATES.PROCESSING) {
                recorderView.classList.remove('hidden');
                recordButton.classList.add('disabled-button');
                statusTextEl.textContent = 'Elaborazione audio...';
            } else if (state === STATES.FINISHED) {
                playerView.classList.remove('hidden');
                recorderView.classList.remove('hidden'); // Mostra anche la vista del registratore
                recordButton.classList.add('disabled-button'); // Disabilita il pulsante
                statusTextEl.textContent = 'Registrazione completata';

                audioPlayer.src = mp3Url;
                downloadButton.href = mp3Url;
                downloadButton.download = `registrazione-${new Date().toISOString().slice(0,19).replace('T', '_').replace(/:/g, '-')}.mp3`;
            }
        };

        // Gestione Timer
        const startTimer = () => {
            let seconds = 0;
            timerInterval = setInterval(() => {
                seconds++;
                const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                timerEl.textContent = `${minutes}:${secs}`;
            }, 1000);
        };

        const stopTimer = () => {
            clearInterval(timerInterval);
        };
        
        // Funzione per scegliere il MIME type
        const getSupportedMimeType = () => {
            const types = ['audio/mp4', 'audio/webm'];
            for (const type of types) {
                if (MediaRecorder.isTypeSupported(type)) {
                    return type;
                }
            }
            return null;
        };


        // Logica di registrazione
        const startRecording = async () => {
            if (currentState !== STATES.IDLE) return;

            const mimeType = getSupportedMimeType();
            if (!mimeType) {
                alert('Il tuo browser non supporta nessun formato di registrazione audio adatto.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream, { mimeType });

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    updateUI(STATES.PROCESSING);
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    
                    try {
                        const mp3Blob = await convertToMp3(audioBlob);
                        mp3Url = URL.createObjectURL(mp3Blob);
                        updateUI(STATES.FINISHED);
                    } catch(e) {
                        console.error("Errore durante la conversione in MP3:", e);
                        alert("Si è verificato un errore durante la conversione dell'audio. Riprova.");
                        resetApp();
                    }
                };

                mediaRecorder.start();
                startTimer();
                updateUI(STATES.RECORDING);

            } catch (err) {
                console.error("Errore nell'accesso al microfono:", err);
                alert("Non è stato possibile accedere al microfono. Assicurati di aver dato i permessi necessari.");
                updateUI(STATES.IDLE);
            }
        };

        const stopRecording = () => {
            if (currentState !== STATES.RECORDING || !mediaRecorder) return;
            mediaRecorder.stop();
            stopTimer();
            // Ferma anche le tracce del microfono per spegnere l'indicatore
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        };
        
        // Conversione a MP3
        const convertToMp3 = (audioBlob) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioContext.decodeAudioData(event.target.result, (buffer) => {
                        const mp3encoder = new lamejs.Mp3Encoder(1, buffer.sampleRate, 128); // 1 canale, sample rate, 128kbps
                        const pcmData = buffer.getChannelData(0);

                        // LAME.js si aspetta campioni a 16-bit, non Float32
                        const samples = new Int16Array(pcmData.length);
                        for (let i = 0; i < pcmData.length; i++) {
                            samples[i] = pcmData[i] * 32767.5;
                        }

                        const mp3Data = [];
                        const sampleBlockSize = 1152;
                        for (let i = 0; i < samples.length; i += sampleBlockSize) {
                            const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                            const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
                            if (mp3buf.length > 0) {
                                mp3Data.push(new Int8Array(mp3buf));
                            }
                        }
                        const mp3buf = mp3encoder.flush();
                        if (mp3buf.length > 0) {
                            mp3Data.push(new Int8Array(mp3buf));
                        }
                        
                        const blob = new Blob(mp3Data, {type: 'audio/mp3'});
                        resolve(blob);

                    }, (error) => {
                         console.error('decodeAudioData error', error);
                         reject(error);
                    });
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(audioBlob);
            });
        };

        // Gestione Player
        const togglePlayPause = () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                audioPlayer.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        };

        const updateProgressBar = () => {
            const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
            progressBar.value = percentage;
        };

        const seek = (e) => {
            const time = (e.target.value / 100) * audioPlayer.duration;
            audioPlayer.currentTime = time;
        };

        audioPlayer.addEventListener('timeupdate', updateProgressBar);
        audioPlayer.addEventListener('loadedmetadata', () => {
            const minutes = Math.floor(audioPlayer.duration / 60).toString().padStart(2, '0');
            const seconds = Math.floor(audioPlayer.duration % 60).toString().padStart(2, '0');
            durationEl.textContent = `${minutes}:${seconds}`;
            progressBar.value = 0;
        });
        audioPlayer.addEventListener('ended', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            progressBar.value = 0;
            audioPlayer.currentTime = 0;
        });

        // Reset
        const resetApp = () => {
            stopTimer();
            if (mp3Url) {
                URL.revokeObjectURL(mp3Url);
                mp3Url = null;
            }
            audioPlayer.src = '';
            audioChunks = [];
            progressBar.value = 0;
            durationEl.textContent = '00:00';
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            updateUI(STATES.IDLE);
        };


        // Event Listeners
        recordButton.addEventListener('click', () => {
            if (currentState === STATES.IDLE) {
                startRecording();
            } else if (currentState === STATES.RECORDING) {
                stopRecording();
            }
        });

        playPauseButton.addEventListener('click', togglePlayPause);
        progressBar.addEventListener('input', seek);
        newRecordingButton.addEventListener('click', resetApp);
        
        // Inizializzazione
        updateUI(STATES.IDLE);

    </script>
</body>
</html>
